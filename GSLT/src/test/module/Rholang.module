import "UnivAlg.module" as u

Module Rholang {
  Theory ParMonoid(cm: u.CommutativeMonoid) {
    cm
      .addReplacements (
        One.Proc => PZero.Proc ::= "0";
        Mult.Proc => PPar.Proc ::= "(" Proc "|" Proc ")";
      )
      .addRewrites (
        RPar1 : let Src ~> Tgt in
                ( PPar Src Q ) ~> ( PPar Tgt Q ) ;
        RPar2 : let Src1 ~> Tgt1 in
                let Src2 ~> Tgt2 in
                ( PPar Src1 Src2 ) ~> ( PPar Tgt1 Tgt2 ) ;
      )
  }

  Theory NewReplCalc(pm: ParMonoid) {
    pm
      .addExports (
        Name ;
      )
      .addTerms (
        PRepl . Proc ::= "!" Proc ;
        PNew  . Proc ::= "new" (Bind Name [1]) "in" Proc ;
      )
      .addEquations (
        if x # Q then
          ( PPar ( PNew x P ) Q ) == ( PNew x ( PPar P Q ) ) ;
        ( PNew x ( PNew x P ) ) == ( PNew x P ) ;
        ( PNew x ( PNew y P ) ) == ( PNew y ( PNew x P ) ) ;
        ( PRepl P ) == ( PPar P ( PRepl P ) ) ;
      )
      .addRewrites (
        RNew  : let Src ~> Tgt in
                (PNew x Src) ~> (PNew x Tgt) ;
      )
  }
 
  Theory QuoteDropCalc(pm: ParMonoid) {
    pm
      .addExports (
        Name ;
      )
      .addTerms (
        PDrop . Proc ::= "*" Name ;
        NQuote . Name ::= "@" Proc ;
      )
      .addEquations (
        ( NQuote ( PDrop N ) ) == N ;
        ( PDrop ( NQuote P ) ) == P ;
      )
  }

  Theory RhoCalc(qd: QuoteDropCalc) {
    qd
      .addTerms (
        PSend . Proc ::= Name "!" "(" Proc ")" ;
        PRecv . Proc ::= "for" "(" (Bind Name [2]) "<-" Name ")" "{" Proc "}" ;
      )
      .addRewrites (
        RComm : ( PPar ( PRecv y x P) ( PSend x Q ) ) ~> ( Subst P ( NQuote Q ) y ) ;
      )
  }

  Theory Rholang(nr: NewReplCalc, r: RhoCalc) {
    nr \/ r
  }
  
  Theory FreeRholang() {
    let m = Monoid(Nil) in (
    let cm = CommutativeMonoid(m) in (
    let pm = ParMonoid(cm) in (
    let qd = QuoteDropCalc(pm) in (
    let nr = NewReplCalc(pm) in (
    let rc = Rhocalc(qd) in (
    let rl = Rholang(nr, rc) in (
    r1
    )))))))
  }
  
  free(FreeRholang)
  -- free(Rholang)
}
