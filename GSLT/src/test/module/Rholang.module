Module Rholang {
  Theory Monoid() {
    new()
      .addExports(
        Proc;
      )
      .addTerms(
        One . Proc ::= "1" ;
        Mult . Proc ::= "(" Proc "*" Proc ")" ;
      )
      .addEquations(
        (Mult (Mult x y) z) == (Mult x (Mult y z));
        (Mult x (One)) == x;
        (Mult (One) x) == x;
      )
  }

  Theory CommutativeMonoid(m: u.Monoid) {
    m
      .addExports(
        Proc;
      )
      .addEquations(
        (Mult x y) == (Mult y x);
      )
  }
  
  Theory ParMonoid(cm: CommutativeMonoid) {
    cm
      .addReplacements (
        One.Proc => PZero.Proc ::= "0";
        Mult.Proc => PPar.Proc ::= "(" Proc "|" Proc ")";
      )
      .addRewrites (
        RPar1 : let Src ~> Tgt in
                ( PPar Src Q ) ~> ( PPar Tgt Q ) ;
        RPar2 : let Src1 ~> Tgt1 in
                let Src2 ~> Tgt2 in
                ( PPar Src1 Src2 ) ~> ( PPar Tgt1 Tgt2 ) ;
      )
  }

  Theory NewReplCalc(pm: ParMonoid) {
    pm
      .addExports (
        Name ;
      )
      .addTerms (
        PRepl . Proc ::= "!" Proc ;
        PNew  . Proc ::= "new" (Bind Name [1]) "in" Proc ;
      )
      .addEquations (
        if x # Q then
          ( PPar ( PNew x P ) Q ) == ( PNew x ( PPar P Q ) ) ;
        ( PNew x ( PNew x P ) ) == ( PNew x P ) ;
        ( PNew x ( PNew y P ) ) == ( PNew y ( PNew x P ) ) ;
        ( PRepl P ) == ( PPar P ( PRepl P ) ) ;
      )
      .addRewrites (
        RNew  : let Src ~> Tgt in
                (PNew x Src) ~> (PNew x Tgt) ;
      )
  }
 
  Theory QuoteDropCalc(pm: ParMonoid) {
    pm
      .addExports (
        Name ;
      )
      .addTerms (
        PDrop . Proc ::= "*" Name ;
        NQuote . Name ::= "@" Proc ;
      )
      .addEquations (
        ( NQuote ( PDrop N ) ) == N ;
        ( PDrop ( NQuote P ) ) == P ;
      )
  }

  Theory RhoCalc(qd: QuoteDropCalc) {
    qd
      .addTerms (
        PSend . Proc ::= Name "!" "(" Proc ")" ;
        PRecv . Proc ::= "for" "(" (Bind Name [2]) "<-" Name ")" "{" Proc "}" ;
      )
      .addRewrites (
        RComm : ( PPar ( PRecv y x P) ( PSend x Q ) ) ~> ( Subst P ( NQuote Q ) y ) ;
      )
  }

  Theory Rholang(nr: NewReplCalc, r: RhoCalc) {
    nr.union(r)
  }
}
